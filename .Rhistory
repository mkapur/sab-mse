lwr.temp <- upr.temp <- map_srvslx ## now there are only values where we need to fill them
## identify which fleets were fixed by just looking at first block
# mappy_srvslx <- mappy[[grep("log_srv_slx_pars", names(mappy))]]
# Nas <- which(is.na(mappy_srvslx)[1:16])
#
#   # which(is.na(mappy[[grep("log_srv_slx_pars", names(mappy))]][1:32]))
# nfixedfleets <- length(Nas)/2
# keptflts <- dimnames(df$parms$log_srv_slx_pars)[[1]][-Nas] ## return non-fixed fltnames
#
# lwr.temp <- upr.temp <- array(1:length(obj$par[names(obj$par) == "log_srv_slx_pars"]),
#       dim = c(8-nfixedfleets,2,max(df$srv_blks_size),2),
#       dimnames = list(keptflts,c('p1','p2'),
#                       c('block',1:max(df$srv_blks_size)),c('Fem','Mal')))
if(all(!is.na(map_srvslx['AK_VAST_W',,1,]))){
lwr.temp['AK_VAST_W',"p1",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(35);
upr.temp['AK_VAST_W',"p1",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(55);
lwr.temp['AK_VAST_W',"p2",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(35);
upr.temp['AK_VAST_W',"p2",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(55)
}
if(all(!is.na(map_srvslx['AK_VAST_E',,1,]))){
lwr.temp['AK_VAST_E',"p1",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(35);
upr.temp['AK_VAST_E',"p1",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(45)
lwr.temp['AK_VAST_E',"p2",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(50);
upr.temp['AK_VAST_E',"p2",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(70)
}
if('BC_EARLY' %in% df$fltnames_surv){
if(all(!is.na(map_srvslx['BC_EARLY',,1,]))){
lwr.temp['BC_EARLY',"p1",1:df$srv_blks_size[,'BC_EARLY'],] <- log(20);
upr.temp['BC_EARLY',"p1",1:df$srv_blks_size[,'BC_EARLY'],] <- log(40)
lwr.temp['BC_EARLY',"p2",1:df$srv_blks_size[,'BC_EARLY'],] <- log(45);
upr.temp['BC_EARLY',"p2",1:df$srv_blks_size[,'BC_EARLY'],] <- log(80)
}
} else{
if(all(!is.na(map_srvslx['BC_OFFStd',,1,]))){
lwr.temp['BC_OFFStd',"p1",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(0);
upr.temp['BC_OFFStd',"p1",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(80)
lwr.temp['BC_OFFStd',"p2",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(0);
upr.temp['BC_OFFStd',"p2",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(80)
}
}
if('BC_VAST' %in% df$fltnames_surv){
if(all(!is.na(map_srvslx['BC_VAST',,1,]))){
lwr.temp['BC_VAST',"p1",1:df$srv_blks_size[,'BC_VAST'],] <- 3.401197;
upr.temp['BC_VAST',"p1",1:df$srv_blks_size[,'BC_VAST'],] <-3.68887945
lwr.temp['BC_VAST',"p2",1:df$srv_blks_size[,'BC_VAST'],] <- 4.007333;
upr.temp['BC_VAST',"p2",1:df$srv_blks_size[,'BC_VAST'],] <- 4.24849524
}
} else{
if(all(!is.na(map_srvslx['BC_StRs',,1,]))){
lwr.temp['BC_StRs',"p1",1:df$srv_blks_size[,'BC_StRs'],] <- log(25);
upr.temp['BC_StRs',"p1",1:df$srv_blks_size[,'BC_StRs'],] <- log(55)
lwr.temp['BC_StRs',"p2",1:df$srv_blks_size[,'BC_StRs'],] <- log(25);
upr.temp['BC_StRs',"p2",1:df$srv_blks_size[,'BC_StRs'],] <- log(70)
}
}
if(all(!is.na(map_srvslx['WC_VAST',,1,]))){
lwr.temp['WC_VAST',"p1",1:df$srv_blks_size[,'WC_VAST'],] <- log(30);
upr.temp['WC_VAST',"p1",1:df$srv_blks_size[,'WC_VAST'],] <- log(70)
lwr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],'Mal'] <- log(40);
lwr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],'Fem'] <- log(40);
upr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],] <- log(70)
}
lower[names(lower) == 'log_srv_slx_pars'] <- lwr.temp[!is.na(lwr.temp)]
upper[names(upper) == 'log_srv_slx_pars'] <- upr.temp[!is.na(upr.temp)]
} else if(length(grep("log_srv_slx_pars", names(mappy)))  == 0){
seeddim = length(df$selType_surv)
lower[names(lower) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
lower[names(lower) == 'log_srv_slx_pars'][c(all(seeddim+1):(2*seeddim),(3*seeddim+1):(4*seeddim))] <- log(70) ## p2
upper[names(upper) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
upper[names(upper) == 'log_srv_slx_pars'][c(all(seeddim+1):(2*seeddim),(3*seeddim+1):(4*seeddim))] <- log(70) ## p2
## custom bounds
# upper[names(upper) == 'log_srv_slx_pars'][c(3,19)] <- log(75) ## BCEARLY P1
# upper[names(upper) == 'log_srv_slx_pars'][c(11,27)] <- log(75) ## BCEARLY P2
# lower[names(lower) == 'log_srv_slx_pars'][c(11,27)] <- log(10) ## BCEARLY P2
# upper[names(upper) == 'log_srv_slx_pars'][c(2,18)] <- log(80) ## AKVASTE P1
# upper[names(upper) == 'log_srv_slx_pars'][c(3,19)] <- log(80) ## BCEARLY P1
# upper[names(upper) == 'log_srv_slx_pars'][10] <- log(85) ## AKVASTE P2 fem only
# upper[names(upper) == 'log_srv_slx_pars'][20] <- log(80) ## BCVAST P1 MALE only
# upper[names(upper) == 'log_srv_slx_pars'][c(11,27)] <- log(85) ## BCEARLY P2
# upper[names(upper) == 'log_srv_slx_pars'][c(11,27)] <- log(85) ## BCEARLY P2
# lower[names(lower) == 'log_srv_slx_pars'] <- 0
# upper[names(upper) == 'log_srv_slx_pars']<- log(80)
}
} ## end srv in boundslx
return(list("upper"=upper, "lower"=lower,
"srv_bnds_lwr" = lwr.temp,"srv_bnds_upr" = upr.temp))
}
## build fish bounds as if everything is there, then remove fixed fleets
## will have same dims as mappy and df$parms
fsh_slx_map_lower <- fsh_slx_map_upper <- array(rep(NA,length(mappy$log_fsh_slx_pars)),
dim = dim(df$parms$log_fsh_slx_pars),
dimnames = dimnames(df$parms$log_fsh_slx_pars))
## if no fleets to fix, go with the normal slx bounds
p1_logistic_idx <- c(1:2,15:16) #c(1:4,19:22)
p2_logistic_idx <- p1_logistic_idx+df$nfleets_fish
p1_norm_idx <- c(3,4,6,7,17,18,20,21)  #c(5,6,8,9,23,24,26,27)
p2_norm_idx <- p1_norm_idx+df$nfleets_fish
p1_gamma_idx <- c(5,19)#c(7,25)
p2_gamma_idx <- p1_gamma_idx+df$nfleets_fish
# ## logistic p1 (a50)
fsh_slx_map_lower[p1_logistic_idx] <-  log(35)
## logistic p2 (a95)
fsh_slx_map_lower[p2_logistic_idx] <-  log(60)
## normal p1 (mean)
fsh_slx_map_lower[p1_norm_idx] <-  log(15)
## normal p2 (sd)
fsh_slx_map_lower[p2_norm_idx] <-  log(1)
## gamma shape (k*theta equals mean)
fsh_slx_map_lower[p1_gamma_idx] <-log(15)
## gamma rate
fsh_slx_map_lower[p2_gamma_idx] <-  log(2)
# #* fsh slx upper bounds ----
# ## logistic p1 (a50)
fsh_slx_map_upper[p1_logistic_idx] <-  log(60)
## logistic p2 (a95)
fsh_slx_map_upper[p2_logistic_idx] <-log(70)
## normal p1 (mean)
fsh_slx_map_upper[p1_norm_idx] <-log(65)
## normal p2 (sd)
fsh_slx_map_upper[p2_norm_idx] <- log(15)
## gamma shape (k*theta equals mean)
fsh_slx_map_upper[p1_gamma_idx] <- log(35)
## gamma rate
fsh_slx_map_upper[p2_gamma_idx] <- log(2)
##  check if slx was fixed at all
if(length(grep("log_fsh_slx_pars", names(mappy))) != 0){
## identify positions of fixed fleet pars
Nas <- which(is.na(mappy[[grep("log_fsh_slx_pars", names(mappy))]]))
## drop these from master bounds array
fsh_slx_map_upper <- fsh_slx_map_upper[-Nas]
fsh_slx_map_lower <- fsh_slx_map_lower[-Nas]
## only for sanity check
# nfixedfleets <- length(Nas)/4
# seeddim <- df$nfleets_fish-nfixedfleets
# length(fsh_slx_map_upper) ==  length(mappy$log_fsh_slx_pars)-length(Nas)
# array(fsh_slx_map_upper, dim = c(seeddim,2,1,2))
# array(1:length(obj$par[names(obj$par) == "log_fsh_slx_pars"]), dim = c(6,2,2))
## identify which fleets were NA
# rownames(mappy$log_fsh_slx_pars)
# which(is.na(mappy[[grep("log_fsh_slx_pars", mappy)]]))
}
length(grep("log_fsh_slx_pars", names(mappy))) != 0
length(grep("log_srv_slx_pars", names(mappy)))  > 0
else if(length(grep("log_srv_slx_pars", names(mappy)))  == 0
seeddim = length(df$selType_surv)
lower[names(lower) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
lower[names(lower) == 'log_srv_slx_pars'][c(all(seeddim+1):(2*seeddim),(3*seeddim+1):(4*seeddim))] <- log(70) ## p2
upper[names(upper) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
seeddim
seeddim
lower[names(lower) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))]
lower[names(lower) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
lower[names(lower) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
lower[names(lower) == 'log_srv_slx_pars'][c(seeddim+1:(2*seeddim),(3*seeddim+1):(4*seeddim))] <- log(70) ## p2
upper[names(upper) == 'log_srv_slx_pars'][c(1:seeddim,(2*seeddim+1):(3*seeddim))] <- log(30) ## p1
upper[names(upper) == 'log_srv_slx_pars'][c(seeddim+1:(2*seeddim),(3*seeddim+1):(4*seeddim))] <- log(70) ## p2
surv_vals <- read.csv(here("input","input_data","OM_indices_STITCH.csv"))
require(here)
surv_vals <- read.csv(here("input","input_data","OM_indices_STITCH.csv"))
require(dplyr)
require(ggplot2)
#* survey plot ----
surv_vals %>%
mutate(Year = 1960:2019) %>%
melt(id = "Year") %>%
filter(value > 0) %>%
ggplot(., aes(x = Year, y = value, color = variable)) +
theme_sleek(base_size = 16) +
theme(legend.position = c(0.8,0.2)) +
scale_color_manual(values = survfltPal)+
scale_x_continuous(breaks = seq(1970,2020,10)) +
geom_line(lwd = 1) +
labs(x = 'Year', y = 'Index of Relative Abundance', color = 'Survey fleet') +
facet_wrap(~variable, scales = 'free_y')
require(reshape2)
#* survey plot ----
surv_vals %>%
mutate(Year = 1960:2019) %>%
melt(id = "Year") %>%
filter(value > 0) %>%
ggplot(., aes(x = Year, y = value, color = variable)) +
theme_sleek(base_size = 16) +
theme(legend.position = c(0.8,0.2)) +
scale_color_manual(values = survfltPal)+
scale_x_continuous(breaks = seq(1970,2020,10)) +
geom_line(lwd = 1) +
labs(x = 'Year', y = 'Index of Relative Abundance', color = 'Survey fleet') +
facet_wrap(~variable, scales = 'free_y')
## One-timer script to process data in raw_data folder.
## If applicable, notes are included on manipulations to data that couldn't be done in R or were done elsewhere.
## all processed files are stored in input_data for use in load_data_seasons.R
## on the fly visualizations of input data are also produced here.
## fall 2020 kapurm@uw.edu
require(tidyverse)
require(reshape2)
require(r4ss)
require(here)
require(ggplot2)
require(ggsidekick)
require(PNWColors)
require(ggpattern)
## 2019 Sab WC SS ----
survfltPal <-  matrix(PNWColors::pnw_palette(name = 'Bay',n=5), ncol = 5) ## for VAST outputs
#* survey plot ----
surv_vals %>%
mutate(Year = 1960:2019) %>%
melt(id = "Year") %>%
filter(value > 0) %>%
ggplot(., aes(x = Year, y = value, color = variable)) +
theme_sleek(base_size = 16) +
theme(legend.position = c(0.8,0.2)) +
scale_color_manual(values = survfltPal)+
scale_x_continuous(breaks = seq(1970,2020,10)) +
geom_line(lwd = 1) +
labs(x = 'Year', y = 'Index of Relative Abundance', color = 'Survey fleet') +
facet_wrap(~variable, scales = 'free_y')
ggsave(last_plot(),
file = here('input','input_data','input_figs',
'OM_indices_STITCH.png'),
height = 8, width = 10, unit = 'in', dpi = 420)
fltnames
## Fltnames ----
fltnames <- read.table(here("input","input_data","OM_fleetnames.txt"), header = TRUE)
fltnames
survey
surv_vals
## OM_Master.R
## Code to condition & forecast 6-area Operating model for Transboundary Sablefish MSE
## M S Kapur kapurm@uw.edu
## Inspiration & code guidance from J Sullivan, N Jacobsen Summer 2020++
rm(list = ls())
# devtools::install_github('kaskr/adcomp', subdir = 'TMB')
library(TMB)
library(dplyr)
library(reshape2)
library(ggplot2)
library(r4ss)
library(here)
library(ggsidekick)
dllUSE = c('shire_v4_1')[1]
compile(here("TMB",paste0(dllUSE,".cpp")))
dyn.load(dynlib(here("TMB",dllUSE)))
source(here("R","functions",'load_files_OM.R'))
yr_future <- 20
df <- load_data_OM(nspace = 6,
move = TRUE,
yr_future  = yr_future,
b_y_max = 0.109) ## data that works with OM
df$parms$mort_k <- c(0.2,0.2,0.2,0.2)
df$Neqn <- buildNeqn(df)
df$parms$b_y <- rep(1,df$tEnd) ## 1 is no ramp (exp(-0.5*B) in recruits; b*lnRy in like))
df$F_yf_HCR <- array(0.2, dim = c(ifelse(yr_future == 0,1,yr_future), df$nfleets_fish))
# df$selShape_surv[4] <- -1 # constant slx for bc vast
## if by is low, the likelihood is weighted more strongly, and the model is given less
## flexibility in generating R_ys in the context of SDRs (aka do a better job of fitting
# data during this period)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_y",
"b_y",
"epsilon_tau",
"logpi_acomp",
# "log_fsh_slx_pars",
# "log_srv_slx_pars",
"mort_k"))#,
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy, ## fix everything for testing eigen fails
checkParameterOrder = TRUE))
lower <- obj$par-Inf
upper <- obj$par+Inf
length(grep("log_srv_slx_pars", names(mappy)))  > 0
length(grep("log_srv_slx_pars", names(mappy)))  == 0
map_srvslx <- array(as.numeric(df$parms$log_srv_slx_pars),
dim = c(length(df$selShape_surv),2,max(df$srv_blks_size),2),
dimnames = dimnames(df$parms$log_srv_slx_pars))
map_srvslx
#* if all estimated ----
map_srvslx <- array(as.numeric(mappy$log_srv_slx_pars),
dim = c(length(df$selShape_surv),2,max(df$srv_blks_size),2),
dimnames = dimnames(df$parms$log_srv_slx_pars))
lwr.temp <- upr.temp <- map_srvslx ## now there are only values where we need to fill them
lwr.temp['AK_VAST_W',"p1",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(35);
upr.temp['AK_VAST_W',"p1",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(55);
lwr.temp['AK_VAST_W',"p2",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(35);
upr.temp['AK_VAST_W',"p2",1:df$srv_blks_size[,'AK_VAST_W'],] <- log(55)
lwr.temp['AK_VAST_E',"p1",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(35);
upr.temp['AK_VAST_E',"p1",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(45)
lwr.temp['AK_VAST_E',"p2",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(50);
upr.temp['AK_VAST_E',"p2",1:df$srv_blks_size[,'AK_VAST_E'],] <- log(70)
upr.temp['BC_OFFStd',"p1",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(80)
lwr.temp['BC_OFFStd',"p2",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(0);
lwr.temp['BC_OFFStd',"p1",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(0);
upr.temp['BC_OFFStd',"p2",1:df$srv_blks_size[,'BC_OFFStd'],] <- log(80)
upr.temp['BC_StRs',"p1",1:df$srv_blks_size[,'BC_StRs'],] <- log(55)
upr.temp['BC_StRs',"p2",1:df$srv_blks_size[,'BC_StRs'],] <- log(70)
lwr.temp['BC_StRs',"p1",1:df$srv_blks_size[,'BC_StRs'],] <- log(25);
lwr.temp['WC_VAST',"p1",1:df$srv_blks_size[,'WC_VAST'],] <- log(30);
upr.temp['WC_VAST',"p1",1:df$srv_blks_size[,'WC_VAST'],] <- log(70)
lwr.temp['BC_StRs',"p2",1:df$srv_blks_size[,'BC_StRs'],] <- log(25);
upr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],] <- log(70)
lwr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],'Mal'] <- log(40);
lwr.temp['WC_VAST',"p2",1:df$srv_blks_size[,'WC_VAST'],'Fem'] <- log(40);
lower[names(lower) == 'log_srv_slx_pars'] <- lwr.temp[!is.na(lwr.temp)]
upper[names(upper) == 'log_srv_slx_pars'] <- upr.temp[!is.na(upr.temp)]
lwr.temp
lower[names(lower) == 'log_srv_slx_pars'] <- lwr.temp
upper[names(upper) == 'log_srv_slx_pars'] <- upr.temp
lwr.temp
source('C:/Users/mkapur/Dropbox/UW/sab-mse/R/functions/boundPars.R')
source('C:/Users/mkapur/Dropbox/UW/sab-mse/R/functions/boundPars.R')
bounds <- boundPars(obj,
r0_lower = 0,
boundSlx = c(NA,'fsh','srv')[2:3])
exp(bounds$srv_bnds_lwr)
exp(bounds$srv_bnds_upr)
# df$selShape_surv[4] <- -1 # constant slx for bc vast
## if by is low, the likelihood is weighted more strongly, and the model is given less
## flexibility in generating R_ys in the context of SDRs (aka do a better job of fitting
# data during this period)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_y",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
# "log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh")) #,
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy, ## fix everything for testing eigen fails
checkParameterOrder = TRUE))
rm(list = ls())
# devtools::install_github('kaskr/adcomp', subdir = 'TMB')
library(TMB)
library(dplyr)
library(reshape2)
library(ggplot2)
library(r4ss)
library(here)
library(ggsidekick)
dllUSE = c('shire_v4_1')[1]
compile(here("TMB",paste0(dllUSE,".cpp")))
dyn.load(dynlib(here("TMB",dllUSE)))
source(here("R","functions",'load_files_OM.R'))
yr_future <- 20
df <- load_data_OM(nspace = 6,
move = TRUE,
yr_future  = yr_future,
b_y_max = 0.109) ## data that works with OM
df$parms$mort_k <- c(0.2,0.2,0.2,0.2)
df$Neqn <- buildNeqn(df)
df$parms$b_y <- rep(1,df$tEnd) ## 1 is no ramp (exp(-0.5*B) in recruits; b*lnRy in like))
df$F_yf_HCR <- array(0.2, dim = c(ifelse(yr_future == 0,1,yr_future), df$nfleets_fish))
# df$selShape_surv[4] <- -1 # constant slx for bc vast
## if by is low, the likelihood is weighted more strongly, and the model is given less
## flexibility in generating R_ys in the context of SDRs (aka do a better job of fitting
# data during this period)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_y",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
# "log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh")) #,
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy, ## fix everything for testing eigen fails
checkParameterOrder = TRUE))
bounds <- boundPars(obj,
r0_lower = 0,
boundSlx = c(NA,'fsh','srv')[2:3])
## tmbhelper is returning null OPTS
system.time(opt <-nlminb(obj$par,
obj$fn,
obj$gr,
lower = bounds$lower,
upper = bounds$upper))
compile(here("TMB",paste0(dllUSE,".cpp")))
rm(list = ls())
# devtools::install_github('kaskr/adcomp', subdir = 'TMB')
library(TMB)
library(dplyr)
library(reshape2)
library(ggplot2)
library(r4ss)
library(here)
library(ggsidekick)
dllUSE = c('shire_v4_1')[1]
compile(here("TMB",paste0(dllUSE,".cpp")),R_MAKEVARS_USER = here("suppressMakeVars.txt"))
dyn.load(dynlib(here("TMB",dllUSE)))
TMB::compile(here("TMB",paste0(dllUSE,".cpp")), flags = "-Wno-ignored-attributes")
dllUSE = c('shire_v4_1')[1]
# devtools::install_github('kaskr/adcomp', subdir = 'TMB')
library(TMB)
library(dplyr)
library(reshape2)
library(ggplot2)
library(r4ss)
library(here)
library(ggsidekick)
TMB::compile(here("TMB",paste0(dllUSE,".cpp")), flags = "-Wno-ignored-attributes")
## Code to condition & forecast 6-area Operating model for Transboundary Sablefish MSE
## M S Kapur kapurm@uw.edu
## Inspiration & code guidance from J Sullivan, N Jacobsen Summer 2020++
rm(list = ls())
# devtools::install_github('kaskr/adcomp', subdir = 'TMB')
library(TMB)
library(dplyr)
library(reshape2)
library(ggplot2)
library(r4ss)
library(here)
library(ggsidekick)
dllUSE = c('shire_v4_1')[1]
TMB::compile(here("TMB",paste0(dllUSE,".cpp")), flags = "-Wno-ignored-attributes")
dyn.load(dynlib(here("TMB",dllUSE)))
source(here("R","functions",'load_files_OM.R'))
yr_future <- 20
df <- load_data_OM(nspace = 6,
move = TRUE,
yr_future  = yr_future,
b_y_max = 0.109) ## data that works with OM
df$parms$mort_k <- c(0.2,0.2,0.2,0.2)
df$Neqn <- buildNeqn(df)
df$F_yf_HCR <- array(0.2, dim = c(ifelse(yr_future == 0,1,yr_future), df$nfleets_fish))
# df$selShape_surv[4] <- -1 # constant slx for bc vast
## if by is low, the likelihood is weighted more strongly, and the model is given less
## flexibility in generating R_ys in the context of SDRs (aka do a better job of fitting
# data during this period)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_y",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
# "log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh")) #,
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy,
checkParameterOrder = TRUE))
system.time(rep1 <- obj$report());## one off caclulation using start pars
df$parms$b_y <- rep(1,df$tEnd) ## 1 is no ramp (exp(-0.5*B) in recruits; b*lnRy in like))
bounds <- boundPars(obj,
r0_lower = 0,
boundSlx = c(NA,'fsh','srv')[2:3])
obj2 <- obj
yr_future <- 0
df <- load_data_OM(nspace = 6,
move = TRUE,
yr_future  = yr_future,
b_y_max = 0.109) ## data that works with OM
df$parms$mort_k <- c(0.2,0.2,0.2,0.2)
df$Neqn <- buildNeqn(df)
# df$selShape_surv[4] <- -1 # constant slx for bc vast
## if by is low, the likelihood is weighted more strongly, and the model is given less
## flexibility in generating R_ys in the context of SDRs (aka do a better job of fitting
# data during this period)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_y",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
# "log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh")) #,
df$parms$b_y <- rep(1,df$tEnd) ## 1 is no ramp (exp(-0.5*B) in recruits; b*lnRy in like))
df$F_yf_HCR <- array(0.2, dim = c(ifelse(yr_future == 0,1,yr_future), df$nfleets_fish))
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy,
checkParameterOrder = TRUE))
960/60
bounds <- boundPars(obj,
r0_lower = 0,
boundSlx = c(NA,'fsh','srv')[2:3])
## tmbhelper is returning null OPTS
system.time(opt <-nlminb(obj$par,
obj$fn,
obj$gr,
lower = bounds$lower,
upper = bounds$upper))

kaputils::nestidx()
kaputils::nestidx
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 1:5){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:3){
for(j in 1:3){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*5 ## doens't hange with J; position in vector
rowpos = a+(j-1)*5
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,'\n')
cat(a,"\t",i,"\t",j,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 1:5){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:3){
for(j in 1:3){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*5 ## doens't hange with J; position in vector
rowpos = a+(j-1)*5
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
A_fem
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 1:Nage){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:Nspace){
for(j in 1:Nspace){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*Nage ## doens't hange with J; position in vector
rowpos = a+(j-1)*Nage
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
A_mal[rowpos,colpos] <- df$X_ijas[i,j,a,2]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
colpos
A_fem
View(A_fem)
A_fem[1:10,1:10]
colSums(A_fem)
any(colSums(A_fem) != 1)
any(colSums(A_fem))
which(colSums(A_fem) != 1
)
colSums(A_fem)
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
# Read in the marices
DataFile <- here("_examples","LectB3.txt")
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
S  <- matrix(0, nrow = Ndim, ncol = Ndim)
diag(S) <- exp(-0.2/2)
# Identity matrix - will be used often
I <- matrix(0,ncol=Ndim,nrow=Ndim); diag(I) = 1
FindEqn <- function(FF=0)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
#print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
# Return
Outs <- NULL
Outs$FF <- FF
Outs$Neqn <- Neqn
Outs$Catch <- Catch
return(Outs)
}
FindEqn <- function(FF=0)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
# Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
#
# # Return
# Outs <- NULL
# Outs$FF <- FF
# Outs$Neqn <- Neqn
# Outs$Catch <- Catch
return(Neqn)
}
FindEqn <- function(FF=0)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
# Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
#
# # Return
# Outs <- NULL
# Outs$FF <- FF
# Outs$Neqn <- Neqn
# Outs$Catch <- Catch
return(Neqn)
}
# =================================================================================
FindEqn(FF = 0)
FindEqn <- function(FF=0)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
# Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
#
# # Return
# Outs <- NULL
# Outs$FF <- FF
# Outs$Neqn <- Neqn
# Outs$Catch <- Catch
return(Neqn)
}
# =================================================================================
FindEqn(FF = 0)
FindEqn <- function(FF=0, A = A_fem)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
# Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
#
# # Return
# Outs <- NULL
# Outs$FF <- FF
# Outs$Neqn <- Neqn
# Outs$Catch <- Catch
return(Neqn)
}
# =================================================================================
FindEqn(FF = 0, A = A_fem)
neqF <- FindEqn(FF = 0, A = A_fem)
neqm <- FindEqn(FF = 0, A = A_mal)
neqm
dim(neqF)
str(neqF)
neqF[neqF!=0]
S
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
A = A_fem
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
FF=0
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
Mat2
Nage <- df$nage-4; Nspace <- df$nspace; Ndim <- Nage*Nspace
DataFile <- here("_examples","LectB3.txt")
# S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
S  <- matrix(0, nrow = Ndim, ncol = Ndim)
diag(S) <- exp(-0.2/2)
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 4:Nage){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:Nspace){
for(j in 1:Nspace){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*Nage ## doens't hange with J; position in vector
rowpos = a+(j-1)*Nage
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
A_mal[rowpos,colpos] <- df$X_ijas[i,j,a,2]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 1:Nage){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:Nspace){
for(j in 1:Nspace){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*Nage ## doens't hange with J; position in vector
rowpos = a+(j-1)*Nage
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
A_mal[rowpos,colpos] <- df$X_ijas[i,j,a,2]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
Nage <- df$nage-4; Nspace <- df$nspace; Ndim <- Nage*Nspace
# Read in the marices
# DataFile <- here("_examples","LectB3.txt")
# S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
S  <- matrix(0, nrow = Ndim, ncol = Ndim)
diag(S) <- exp(-0.2/2)
## only need to update this with movement
A_fem <- A_mal <- matrix(0, nrow = Ndim, ncol = Ndim)
## easier to make simple space x age matrix for each, then stich
for(a in 1:Nage){
# tempvec = matrix(0, ncol = 1, nrow = Ndim)
for(i in 1:Nspace){
for(j in 1:Nspace){
## working with one source area at a time, make a vertical vector for the age at hand
## the position (row) for the infill is a recurisve function of the age and block position
## tis is the same position to be used to index columns of final product
colpos = a+(i-1)*Nage ## doens't hange with J; position in vector
rowpos = a+(j-1)*Nage
cat(a,"\t",i,"\t",j,"\t rowpos = ",rowpos,"\t colpos = ",colpos,'\n')
A_fem[rowpos,colpos] <- df$X_ijas[i,j,a,1]
A_mal[rowpos,colpos] <- df$X_ijas[i,j,a,2]
# tempvec[position0] <- df$X_ijas[i,j,a,1]
# }
# A_fem[,position0] <- tempvec
#
#   atemp_fem <- atemp_mal <-matrix(0, nrow = Nage, ncol = Nage) ## block for one area
#
#     diag(atemp_fem) = df$X_ijas[i,i,,1] ## stay in area, will become diag
#     diag(atemp_mal) = df$X_ijas[i,i,,2] ## stay in area, will become diag
#     A_fem <- append(A_fem, atemp_fem)  ;   A_mal <-    cbind(A_mal, atemp_mal)
#
#     idx = idx+Nage ## bump to next set
}
}
}
colSums(A_fem) ## must all be 1
# Identity matrix - will be used often
I <- matrix(0,ncol=Ndim,nrow=Ndim); diag(I) = 1
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
# H[Nage,Nage] <- 1.0 - 0.2/0.8*FF
H[Nage,Nage] <- 1.0 - FF ## ignore selex unfished
H[Nage+Nage,Nage+Nage] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
S
dim(s)
dim(S)
dim(H)
dim(A)
A = A_fem
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% (S %*% (H %*% S)))
Mat2
which(Mat2 != 0)
Mat2[Mat2!=0]
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
which(Neqn != 0)
Neqn
Mat1
H %*% S
which(Mat2!=0)
Mat2
Mat2[1:40,1:40]
S %*% Neqn
S %*% Test
Test[1] + 1
# Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
Mat2 <- (A %*% H)*exp(-0.2)
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
print(Neqn)
solve(I-Mat2)
sum( solve(I-Mat2) >0)
Ndim
2282/Ndim
2282/Nage
Neqn <- solve(I-Mat2)
Neqn[Neqn >0]
H
# Read in the marices
DataFile <- here("_examples","LectB3.txt")
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
A <- matrix(scan(DataFile,skip=Ndim+2,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
X <- matrix(scan(DataFile,skip=2*Ndim+3,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
DataFile <- here("_examples","LectB3.txt")
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
A <- matrix(scan(DataFile,skip=Ndim+2,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
X <- matrix(scan(DataFile,skip=2*Ndim+3,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
Nsize <- 3; Narea <- 2;Ndim <- Nsize*Narea
# Read in the marices
DataFile <- here("_examples","LectB3.txt")
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
A <- matrix(scan(DataFile,skip=Ndim+2,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
X <- matrix(scan(DataFile,skip=2*Ndim+3,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
Nsize <- 3; Narea <- 2;Ndim <- Nsize*Narea
# Read in the marices
DataFile <- here("_examples","LectB3.txt")
S <- matrix(scan(DataFile,skip=1,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
A <- matrix(scan(DataFile,skip=Ndim+2,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
X <- matrix(scan(DataFile,skip=2*Ndim+3,n=Ndim*Ndim,quiet=T),nrow=Ndim,ncol=Ndim,byrow=T)
# Identity matrix - will be used often
I <- matrix(0,ncol=Ndim,nrow=Ndim); diag(I) = 1
FindEqn <- function(FF=0)
{
# Specify the H matrix
H <- matrix(0,ncol=Ndim,nrow=Ndim); diag(H) = 1
H[Nsize,Nsize] <- 1.0 - 0.2/0.8*FF
H[Nsize+Nsize,Nsize+Nsize] <- 1.0 - FF
# Multiply the matrices
Mat1 <- S
Mat2 <- (X %*% (A %*% (S %*% (H %*% S))))
# Matrix inversion multiplied by a recruitment vector with a 1 in the first row
Neqn <- solve(I-Mat2)[,1]
#print(Neqn)
# Code to chck the equilibrium is correct
#Test <- S %*% Neqn
#Test <- H %*% Test
#Test <- S %*% Test
#Test <- A %*% Test
#Test <- X %*% Test
#Test[1] <- Test[1] + 1
#print(Test-Neqn)
# Compute the yield
Catch <- sum((I-H) %*% (Mat1 %*% Neqn))
# Return
Outs <- NULL
Outs$FF <- FF
Outs$Neqn <- Neqn
Outs$Catch <- Catch
return(Outs)
}
# Part 1 (yield vs F)
FFs <- seq(from=0,to=1,by=0.1)
# =================================================================================
FindEqn(FFs[1])
diag(A_fem)

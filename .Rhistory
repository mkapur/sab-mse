tau_ki <-  matrix(0, ncol = nspace, nrow = nstocks) ## nesting of subareas within stocks, for recruitment purposes
rownames(tau_ki) <- rev(unique(spmat$stock))
colnames(tau_ki) <- rev(spmat$subarea)
tau_ki[1,1] <-   tau_ki[4,6]  <- 1 ## 100% of recruitment in stock
tau_ki[2,2:3] <-  tau_ki[3,5:4] <-  c(0.75,0.25) ## A2 and C1 are larger
} else {
# phi_if_surv <- matrix(rbinom(nfleets_surv*nspace,1,0.5), byrow = TRUE, nrow = nfleets_surv, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_if_fish <- matrix(c(0,1,1,1,1,0), nrow = nfleets_fish, ncol = nspace)  ## placeholder for fishing fleets
# phi_ki <- matrix(c(1,0,0,1), byrow = TRUE, nrow = nstocks, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_ik2 <- apply(phi_ki,2, function(x)which(x == 1))-1 ## a vector for par subsetting, the columns are subareas
#
# # phi_fm <- matrix(0, nrow = nspace, ncol = 2)
# # phi_fm[1,1] <- phi_fm[2,2] <- 1
# phi_fm <- matrix(0, nrow = nfleets_fish, ncol = 3)
# phi_fm[1:2,1] <- phi_fm[3,3]  <- 1
# ## autogenerate stock-distinction matrix
# phi_ij <-  matrix(NA, byrow = TRUE, ncol = nspace, nrow = nspace)
# for(i in 1:nspace){
#   for(j in 1:nspace){
#     phi_ij[i,j] = ifelse(phi_ik2[i] == phi_ik2[j],0,1)
#   }
# }
# tau_ki <- matrix(c(0.25,0.75,0.9,0.1), nrow = nstocks, byrow = TRUE, ncol = nspace) ## placeholder for alternative spatial stratifications
}
nstocks =4
if(nspace == 6){ ## OM
## phi_survy
phi_if_surv <- matrix(0, nrow = nfleets_surv, ncol = nspace)
rownames(phi_if_surv) <- names(survey)
colnames(phi_if_surv) <- rev(spmat$subarea)
# phi_if_surv[1,6] <-  phi_if_surv[2,5] <-
#   phi_if_surv[3:4,3:4]<-  phi_if_surv[5,1:2] <- 1
for(i in 1:nrow(phi_if_surv)){
reg = substr(rownames(phi_if_surv)[i],1,2)
if(reg == 'AK') {
phi_if_surv[i,5:6] <- 1 ## both E/W surveys in both areas
# phi_if_surv[1,6] <- 1 ## AK VAST W (AI) only in a4
# phi_if_surv[2,5] <- 1 ## AK VAST E (GOA) ONLY IN A3
} else  if(reg == 'BC'){
phi_if_surv[i,3:4] <- 1
}else{
phi_if_surv[i,1:2] <- 1
}
}
phi_if_acomp <- matrix(0, nrow = nfleets_acomp, ncol = nspace)
rownames(phi_if_acomp) <- fltnames_acomp
colnames(phi_if_acomp) <- rev(spmat$subarea)
for(i in 1:nrow(phi_if_acomp)){
reg = substr(rownames(phi_if_acomp)[i],1,2)
if(reg == 'AK') {
phi_if_acomp[i,5:6] <- 1
} else  if(reg == 'BC'){
phi_if_acomp[i,3:4] <- 1
}else{
phi_if_acomp[i,1:2] <- 1
}
}
acomp_flt_type <- matrix(1, ncol = nfleets_acomp) ## 0 is commercial, 1 is survey
colnames(acomp_flt_type) <- fltnames_acomp
## match colnames to fltnames which are commercial, assign those as 1
acomp_flt_type[which(fltnames$COMM[which(grepl(paste(colnames(acomp_flt_type), collapse = "|"),fltnames$NAME))])] <- 0
# acomp_flt_type[fltnames$NAME == rownames(acomp_flt_type) ] <- 1
## indicates the position of acomp fleet
phi_ff_acomp <- matrix(-1, nrow = nfleets_acomp, ncol = 5)
rownames(phi_ff_acomp) <- fltnames_acomp
colnames(phi_ff_acomp) <- c('fsh_slx_pos','srv_slx_pos',"nsamp_pos","commacomp_pos","survacomp_pos")
## MANUAL UPDATE WITH COLNAMES [seltypes are in same order as fltnames]
phi_ff_acomp[which(rownames(phi_ff_acomp) %in% paste(fltnames_fish)),1] <-
which(grepl(paste(rownames(phi_ff_acomp), collapse = "|"), paste(fltnames_fish)))-1
if(tolower(x) != 'n'){
phi_ff_acomp[Wnsurvflts_acomp,'srv_slx_pos'] <-
which(fltnames_surv %in% fltnames_acomp )-1## Pos in survey
phi_ff_acomp[acomp_flt_type == 1,"survacomp_pos"] <-
which(fltnames_surv %in% fltnames_acomp[acomp_flt_type == 1])-1
} else{
## if a standalone survey, fill with last idx
phi_ff_acomp[acomp_flt_type == 1,"srv_slx_pos"] <-
(nfleets_surv +1):(nfleets_surv + sum(acomp_flt_type==1))-1
phi_ff_acomp[acomp_flt_type == 1,"survacomp_pos"] <-
(nfleets_surv +1):(nfleets_surv + sum(acomp_flt_type==1))-1
}
phi_ff_acomp[acomp_flt_type == 0,"commacomp_pos"] <-
which(fltnames_fish %in% fltnames_acomp[acomp_flt_type == 0])-1
phi_ff_acomp[,"nsamp_pos"] <- 0:(nrow(phi_ff_acomp)-1)
## phi_fish
phi_if_fish <- matrix(0, nrow = nfleets_fish, ncol = nspace) ## placeholder for fishing fleets
rownames(phi_if_fish) <- names(catch)[2:ncol(catch)]
colnames(phi_if_fish) <-  rev(spmat$subarea)
## works whether you have 7 or 9 fleets
for(i in 1:nrow(phi_if_fish)){
reg = substr(rownames(phi_if_fish)[i],1,2)
if(reg == 'AK') {
phi_if_fish[i,5:6] <- 1
} else  if(reg == 'BC'){
phi_if_fish[i,3:4] <- 1
}else{
phi_if_fish[i,1:2] <- 1
}
}
# phi_if_fish[c(1,3),6] <- phi_if_fish[c(2,4),5] <-   phi_if_fish[5:7,3:4] <-
#   phi_if_fish[c(8,9),1:2] <-  1
## phi_im
phi_im <- matrix(0, ncol = 3, nrow = nspace)
colnames(phi_im) <- rev(unique(spmat$mgmt))
rownames(phi_im) <- rev(spmat$subarea)
phi_im[1:2,1] <- phi_im[3:4,2] <- phi_im[5:6,3] <- 1
## phi_ik
phi_ki <-  matrix(0, ncol = nspace, nrow = nstocks) ## nesting of subareas within stocks, for recruitment purposes
rownames(phi_ki) <- rev(unique(spmat$stock))
colnames(phi_ki) <- rev(spmat$subarea)
phi_ki[1,1] <-  phi_ki[2,2:3] <-  phi_ki[3,4:5]<-  phi_ki[4,6]  <- 1
phi_ik2 <- matrix(apply(phi_ki,2, function(x)which(x == 1))-1) ## a vector for par subsetting, the columns are subareas
## phi_ij [eq 6]
phi_ij <-  matrix(1, ncol = nspace, nrow = nspace) ## 0 indicates  subareas comprise THE SAME stock
rownames(phi_ij) = colnames(phi_ij) = rev(spmat$subarea)
diag(phi_ij) <- phi_ij[2:3,2:3] <- phi_ij[4:5,4:5] <- 0
## phi_fm
phi_fm <- matrix(0, nrow = nfleets_fish, ncol = 3)
rownames(phi_fm) = names(catch)[2:ncol(catch)]
colnames(phi_fm) = rev(unique(spmat$mgmt))
for(i in 1:nrow(phi_fm)){
reg = substr(rownames(phi_fm)[i],1,2)
if(reg == 'AK') {
phi_fm[i,3] <- 1
} else  if(reg == 'BC'){
phi_fm[i,2] <- 1
}else{
phi_fm[i,1] <- 1
}
}
## same as above but for comps (mix of fisheries & surveys)
phi_fm_acomp <- matrix(0, nrow = nfleets_acomp, ncol = 3)
rownames(phi_fm_acomp) = fltnames_acomp
colnames(phi_fm_acomp) = rev(unique(spmat$mgmt))
for(i in 1:nrow(phi_fm_acomp)){
reg = substr(rownames(phi_fm_acomp)[i],1,2)
if(reg == 'AK') {
phi_fm_acomp[i,3] <- 1
} else  if(reg == 'BC'){
phi_fm_acomp[i,2] <- 1
}else{
phi_fm_acomp[i,1] <- 1
}
}
# phi_fm_acomp[1:3,3] <- phi_fm_acomp[4:6,2]  <- phi_fm_acomp[7:8,1]  <- 1
phi_fm_acomp2 <- matrix(apply(phi_fm_acomp,1, function(x)which(x == 1))-1) ## a vector for par subsetting, the columns are survey fleets
phi_lcomp_fm <- matrix(0, nrow = nfleets_lcomp, ncol = 3)
rownames(phi_lcomp_fm) = fltnames_lcomp
colnames(phi_lcomp_fm) = rev(unique(spmat$mgmt))
# phi_lcomp_fm[1:6,3] <- phi_lcomp_fm[7:9,2]  <- phi_lcomp_fm[10,1]  <- 1
for(i in 1:nrow(phi_lcomp_fm)){
reg = substr(rownames(phi_lcomp_fm)[i],1,2)
if(reg == 'AK') {
phi_lcomp_fm[i,3] <- 1
} else  if(reg == 'BC'){
phi_lcomp_fm[i,2] <- 1
}else{
phi_lcomp_fm[i,1] <- 1
}
}
## tau_ki
tau_ki <-  matrix(0, ncol = nspace, nrow = nstocks) ## nesting of subareas within stocks, for recruitment purposes
rownames(tau_ki) <- rev(unique(spmat$stock))
colnames(tau_ki) <- rev(spmat$subarea)
tau_ki[1,1] <-   tau_ki[4,6]  <- 1 ## 100% of recruitment in stock
tau_ki[2,2:3] <-  tau_ki[3,5:4] <-  c(0.75,0.25) ## A2 and C1 are larger
} else {
# phi_if_surv <- matrix(rbinom(nfleets_surv*nspace,1,0.5), byrow = TRUE, nrow = nfleets_surv, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_if_fish <- matrix(c(0,1,1,1,1,0), nrow = nfleets_fish, ncol = nspace)  ## placeholder for fishing fleets
# phi_ki <- matrix(c(1,0,0,1), byrow = TRUE, nrow = nstocks, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_ik2 <- apply(phi_ki,2, function(x)which(x == 1))-1 ## a vector for par subsetting, the columns are subareas
#
# # phi_fm <- matrix(0, nrow = nspace, ncol = 2)
# # phi_fm[1,1] <- phi_fm[2,2] <- 1
# phi_fm <- matrix(0, nrow = nfleets_fish, ncol = 3)
# phi_fm[1:2,1] <- phi_fm[3,3]  <- 1
# ## autogenerate stock-distinction matrix
# phi_ij <-  matrix(NA, byrow = TRUE, ncol = nspace, nrow = nspace)
# for(i in 1:nspace){
#   for(j in 1:nspace){
#     phi_ij[i,j] = ifelse(phi_ik2[i] == phi_ik2[j],0,1)
#   }
# }
# tau_ki <- matrix(c(0.25,0.75,0.9,0.1), nrow = nstocks, byrow = TRUE, ncol = nspace) ## placeholder for alternative spatial stratifications
}
## build b_y ramp ----
b_y <- matrix(NA, nyear)
Yr <- 1960:max(years)
nyear =60
if(nspace == 6){ ## OM
## phi_survy
phi_if_surv <- matrix(0, nrow = nfleets_surv, ncol = nspace)
rownames(phi_if_surv) <- names(survey)
colnames(phi_if_surv) <- rev(spmat$subarea)
# phi_if_surv[1,6] <-  phi_if_surv[2,5] <-
#   phi_if_surv[3:4,3:4]<-  phi_if_surv[5,1:2] <- 1
for(i in 1:nrow(phi_if_surv)){
reg = substr(rownames(phi_if_surv)[i],1,2)
if(reg == 'AK') {
phi_if_surv[i,5:6] <- 1 ## both E/W surveys in both areas
# phi_if_surv[1,6] <- 1 ## AK VAST W (AI) only in a4
# phi_if_surv[2,5] <- 1 ## AK VAST E (GOA) ONLY IN A3
} else  if(reg == 'BC'){
phi_if_surv[i,3:4] <- 1
}else{
phi_if_surv[i,1:2] <- 1
}
}
phi_if_acomp <- matrix(0, nrow = nfleets_acomp, ncol = nspace)
rownames(phi_if_acomp) <- fltnames_acomp
colnames(phi_if_acomp) <- rev(spmat$subarea)
for(i in 1:nrow(phi_if_acomp)){
reg = substr(rownames(phi_if_acomp)[i],1,2)
if(reg == 'AK') {
phi_if_acomp[i,5:6] <- 1
} else  if(reg == 'BC'){
phi_if_acomp[i,3:4] <- 1
}else{
phi_if_acomp[i,1:2] <- 1
}
}
acomp_flt_type <- matrix(1, ncol = nfleets_acomp) ## 0 is commercial, 1 is survey
colnames(acomp_flt_type) <- fltnames_acomp
## match colnames to fltnames which are commercial, assign those as 1
acomp_flt_type[which(fltnames$COMM[which(grepl(paste(colnames(acomp_flt_type), collapse = "|"),fltnames$NAME))])] <- 0
# acomp_flt_type[fltnames$NAME == rownames(acomp_flt_type) ] <- 1
## indicates the position of acomp fleet
phi_ff_acomp <- matrix(-1, nrow = nfleets_acomp, ncol = 5)
rownames(phi_ff_acomp) <- fltnames_acomp
colnames(phi_ff_acomp) <- c('fsh_slx_pos','srv_slx_pos',"nsamp_pos","commacomp_pos","survacomp_pos")
## MANUAL UPDATE WITH COLNAMES [seltypes are in same order as fltnames]
phi_ff_acomp[which(rownames(phi_ff_acomp) %in% paste(fltnames_fish)),1] <-
which(grepl(paste(rownames(phi_ff_acomp), collapse = "|"), paste(fltnames_fish)))-1
if(tolower(x) != 'n'){
phi_ff_acomp[Wnsurvflts_acomp,'srv_slx_pos'] <-
which(fltnames_surv %in% fltnames_acomp )-1## Pos in survey
phi_ff_acomp[acomp_flt_type == 1,"survacomp_pos"] <-
which(fltnames_surv %in% fltnames_acomp[acomp_flt_type == 1])-1
} else{
## if a standalone survey, fill with last idx
phi_ff_acomp[acomp_flt_type == 1,"srv_slx_pos"] <-
(nfleets_surv +1):(nfleets_surv + sum(acomp_flt_type==1))-1
phi_ff_acomp[acomp_flt_type == 1,"survacomp_pos"] <-
(nfleets_surv +1):(nfleets_surv + sum(acomp_flt_type==1))-1
}
phi_ff_acomp[acomp_flt_type == 0,"commacomp_pos"] <-
which(fltnames_fish %in% fltnames_acomp[acomp_flt_type == 0])-1
phi_ff_acomp[,"nsamp_pos"] <- 0:(nrow(phi_ff_acomp)-1)
## phi_fish
phi_if_fish <- matrix(0, nrow = nfleets_fish, ncol = nspace) ## placeholder for fishing fleets
rownames(phi_if_fish) <- names(catch)[2:ncol(catch)]
colnames(phi_if_fish) <-  rev(spmat$subarea)
## works whether you have 7 or 9 fleets
for(i in 1:nrow(phi_if_fish)){
reg = substr(rownames(phi_if_fish)[i],1,2)
if(reg == 'AK') {
phi_if_fish[i,5:6] <- 1
} else  if(reg == 'BC'){
phi_if_fish[i,3:4] <- 1
}else{
phi_if_fish[i,1:2] <- 1
}
}
# phi_if_fish[c(1,3),6] <- phi_if_fish[c(2,4),5] <-   phi_if_fish[5:7,3:4] <-
#   phi_if_fish[c(8,9),1:2] <-  1
## phi_im
phi_im <- matrix(0, ncol = 3, nrow = nspace)
colnames(phi_im) <- rev(unique(spmat$mgmt))
rownames(phi_im) <- rev(spmat$subarea)
phi_im[1:2,1] <- phi_im[3:4,2] <- phi_im[5:6,3] <- 1
## phi_ik
phi_ki <-  matrix(0, ncol = nspace, nrow = nstocks) ## nesting of subareas within stocks, for recruitment purposes
rownames(phi_ki) <- rev(unique(spmat$stock))
colnames(phi_ki) <- rev(spmat$subarea)
phi_ki[1,1] <-  phi_ki[2,2:3] <-  phi_ki[3,4:5]<-  phi_ki[4,6]  <- 1
phi_ik2 <- matrix(apply(phi_ki,2, function(x)which(x == 1))-1) ## a vector for par subsetting, the columns are subareas
## phi_ij [eq 6]
phi_ij <-  matrix(1, ncol = nspace, nrow = nspace) ## 0 indicates  subareas comprise THE SAME stock
rownames(phi_ij) = colnames(phi_ij) = rev(spmat$subarea)
diag(phi_ij) <- phi_ij[2:3,2:3] <- phi_ij[4:5,4:5] <- 0
## phi_fm
phi_fm <- matrix(0, nrow = nfleets_fish, ncol = 3)
rownames(phi_fm) = names(catch)[2:ncol(catch)]
colnames(phi_fm) = rev(unique(spmat$mgmt))
for(i in 1:nrow(phi_fm)){
reg = substr(rownames(phi_fm)[i],1,2)
if(reg == 'AK') {
phi_fm[i,3] <- 1
} else  if(reg == 'BC'){
phi_fm[i,2] <- 1
}else{
phi_fm[i,1] <- 1
}
}
## same as above but for comps (mix of fisheries & surveys)
phi_fm_acomp <- matrix(0, nrow = nfleets_acomp, ncol = 3)
rownames(phi_fm_acomp) = fltnames_acomp
colnames(phi_fm_acomp) = rev(unique(spmat$mgmt))
for(i in 1:nrow(phi_fm_acomp)){
reg = substr(rownames(phi_fm_acomp)[i],1,2)
if(reg == 'AK') {
phi_fm_acomp[i,3] <- 1
} else  if(reg == 'BC'){
phi_fm_acomp[i,2] <- 1
}else{
phi_fm_acomp[i,1] <- 1
}
}
# phi_fm_acomp[1:3,3] <- phi_fm_acomp[4:6,2]  <- phi_fm_acomp[7:8,1]  <- 1
phi_fm_acomp2 <- matrix(apply(phi_fm_acomp,1, function(x)which(x == 1))-1) ## a vector for par subsetting, the columns are survey fleets
phi_lcomp_fm <- matrix(0, nrow = nfleets_lcomp, ncol = 3)
rownames(phi_lcomp_fm) = fltnames_lcomp
colnames(phi_lcomp_fm) = rev(unique(spmat$mgmt))
# phi_lcomp_fm[1:6,3] <- phi_lcomp_fm[7:9,2]  <- phi_lcomp_fm[10,1]  <- 1
for(i in 1:nrow(phi_lcomp_fm)){
reg = substr(rownames(phi_lcomp_fm)[i],1,2)
if(reg == 'AK') {
phi_lcomp_fm[i,3] <- 1
} else  if(reg == 'BC'){
phi_lcomp_fm[i,2] <- 1
}else{
phi_lcomp_fm[i,1] <- 1
}
}
## tau_ki
tau_ki <-  matrix(0, ncol = nspace, nrow = nstocks) ## nesting of subareas within stocks, for recruitment purposes
rownames(tau_ki) <- rev(unique(spmat$stock))
colnames(tau_ki) <- rev(spmat$subarea)
tau_ki[1,1] <-   tau_ki[4,6]  <- 1 ## 100% of recruitment in stock
tau_ki[2,2:3] <-  tau_ki[3,5:4] <-  c(0.75,0.25) ## A2 and C1 are larger
} else {
# phi_if_surv <- matrix(rbinom(nfleets_surv*nspace,1,0.5), byrow = TRUE, nrow = nfleets_surv, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_if_fish <- matrix(c(0,1,1,1,1,0), nrow = nfleets_fish, ncol = nspace)  ## placeholder for fishing fleets
# phi_ki <- matrix(c(1,0,0,1), byrow = TRUE, nrow = nstocks, ncol = nspace) ## placeholder for alternative spatial stratifications
# phi_ik2 <- apply(phi_ki,2, function(x)which(x == 1))-1 ## a vector for par subsetting, the columns are subareas
#
# # phi_fm <- matrix(0, nrow = nspace, ncol = 2)
# # phi_fm[1,1] <- phi_fm[2,2] <- 1
# phi_fm <- matrix(0, nrow = nfleets_fish, ncol = 3)
# phi_fm[1:2,1] <- phi_fm[3,3]  <- 1
# ## autogenerate stock-distinction matrix
# phi_ij <-  matrix(NA, byrow = TRUE, ncol = nspace, nrow = nspace)
# for(i in 1:nspace){
#   for(j in 1:nspace){
#     phi_ij[i,j] = ifelse(phi_ik2[i] == phi_ik2[j],0,1)
#   }
# }
# tau_ki <- matrix(c(0.25,0.75,0.9,0.1), nrow = nstocks, byrow = TRUE, ncol = nspace) ## placeholder for alternative spatial stratifications
}
## log_fsh_slx_pars ----
# fsh_blks_size is a 1 x nfleets_surv ivector which indicates the number of timeblocks applicable
# to each fleet.
fsh_blks_size <- matrix(1, nrow = 1, ncol = nfleets_fish)
colnames(fsh_blks_size) <- c( as.character(fltnames_fish))
# fsh_blks_size[,'WC_FIX'] <- 4
# fsh_blks_size[,'WC_TWL'] <- 4
# fsh_blks_size[,'AK_FIX'] <- 2
# fsh_blks is an h x nfleets_fish imatrix with the MAX year of a given timeblock.
# it will be a ragged array bc some fleets have fewer blocks.
fsh_blks <- matrix(2019, nrow = max(fsh_blks_size),
ncol = nfleets_fish)
colnames(fsh_blks) <- c( as.character(fltnames_fish))
# fsh_blks[1:fsh_blks_size[,'WC_FIX'],'WC_FIX' ] <- c(1997,2003,2010,2019)
# fsh_blks[1:fsh_blks_size[,'WC_TWL'],'WC_TWL' ] <- c(1982,2003,2010,2019)
# fsh_blks[1:fsh_blks_size[,'AK_FIX'],'AK_FIX' ] <- c(1995,2019)
fsh_blks <- fsh_blks-1960 ## zero index!
## fill all blocks with start pars
log_fsh_slx_pars = array(NA, dim = c(nfleets_fish,2, max(fsh_blks_size),2),
dimnames = list(c(paste(fltnames_fish)),
c("p1","p2"),
c(paste0('block',1: max(fsh_blks_size))),
c('Fem','Mal')))
## ak fix is logistic
log_fsh_slx_pars["AK_FIX","p1",1:fsh_blks_size[,"AK_FIX"], c('Fem','Mal')] <- log(50)
log_fsh_slx_pars["AK_FIX","p2",1:fsh_blks_size[,"AK_FIX"], c('Fem','Mal')] <-  log(67)
## ak twl is dome normal
log_fsh_slx_pars["AK_TWL","p1",1:fsh_blks_size[,"AK_TWL"], c('Fem','Mal')] <- log(45)
log_fsh_slx_pars["AK_TWL","p2",1:fsh_blks_size[,"AK_TWL"], c('Fem','Mal')] <-  log(10)
## have custom start pars for bc fleets, which are dome normal and gamma
log_fsh_slx_pars["BC_LL","p1",1:fsh_blks_size[,"BC_LL"], c('Fem','Mal')] <- log( 63.6959)
log_fsh_slx_pars["BC_LL","p2",1:fsh_blks_size[,"BC_LL"], c('Fem','Mal')] <-  log(3.09715)
log_fsh_slx_pars["BC_TRAP","p1",1:fsh_blks_size[,"BC_TRAP"], c('Fem','Mal')] <- log( 62.8329)
log_fsh_slx_pars["BC_TRAP","p2",1:fsh_blks_size[,"BC_TRAP"], c('Fem','Mal')] <-  log(7.04483)
log_fsh_slx_pars["BC_TWL","p1",1:fsh_blks_size[,"BC_TWL"], c('Fem','Mal')] <- log( 33.8898)
log_fsh_slx_pars["BC_TWL","p2",1:fsh_blks_size[,"BC_TWL"], c('Fem','Mal')] <-  log(7.04483)
## Just copy dome normal values for wc
log_fsh_slx_pars["WC_FIX","p1",1:fsh_blks_size[,"WC_FIX"], c('Fem','Mal')] <- log(  34.556990,23.53858)
log_fsh_slx_pars["WC_FIX","p2",1:fsh_blks_size[,"WC_FIX"], c('Fem','Mal')] <-  log(30,30)
log_fsh_slx_pars["WC_TWL","p1",1:fsh_blks_size[,"WC_TWL"], c('Fem','Mal')] <- log( 62.8329)
log_fsh_slx_pars["WC_TWL","p2",1:fsh_blks_size[,"WC_TWL"], c('Fem','Mal')] <-  log(7.04483)
# srv_blks_size is a 1 x nfleets_surv ivector which indicates the number of timeblocks applicable
# to each fleet.
srv_blks_size <- matrix(1, nrow = 1, ncol = length(selType_surv))
## this should have the names of all surveys which have slx estimated.
## NEED TO SORT OUT SRV BLKS NAMES
colnames(srv_blks_size) <- c( fltnames_survcomp)
srv_blks_size[,'WC_VAST'] <- 3
srv_blks_size
colnames(srv_blks_size) <- c(as.numeric( fltnames_survcomp))
srv_blks_size
fltnames_survcomp
unique(c(fltnames_surv,fltnames_acomp[-Wnfishflts_acomp]))
fltnames_surv
fltnames_acomp
## later this might need to include lcomps
fltnames_survcomp <-  as.character(unique(c(fltnames_surv,fltnames_acomp[-Wnfishflts_acomp])))
fltnames_survcomp
## later this might need to include lcomps
fltnames_survcomp <-  unique(c(as.character(fltnames_surv),
as.character(fltnames_acomp[-Wnfishflts_acomp]))))
## later this might need to include lcomps
fltnames_survcomp <-  unique(c(as.character(fltnames_surv),
as.character(fltnames_acomp[-Wnfishflts_acomp])))
fltnames_survcomp
colnames(srv_blks_size) <- c(fltnames_survcomp)
srv_blks_size
srv_blks_size[,'WC_VAST'] <- 3
# srv_blks_size[,'AK_VAST_E'] <- 2
# srv_blks is an h x nfleets_surv imatrix with the MAX year of a given timeblock.
# it will be a ragged array bc some fleets have fewer blocks.
srv_blks <- matrix(2019, nrow = max(srv_blks_size),  ncol = length(selType_surv))
colnames(srv_blks) <- c( fltnames_survcomp)
srv_blks[1:srv_blks_size[,'WC_VAST'],'WC_VAST' ] <- c(1995,2003,2019)
# CPPFLAGS="-Wno-ignored-attributes"
source(here("R","functions",'load_files_OM.R'))
df <- load_data_OM(nspace = 6,
move = TRUE,
b_y_max = 0.109) ## data that works with OM
df$surv_yf_obs[df$surv_yf_obs >0] <-  df$surv_yf_obs[df$surv_yf_obs >0]*1000
df$yRun <- df$tEnd ## number of years to run model
df$parms$mort_k <- c(0.2,0.2,0.2,0.2)
df$Neqn <- buildNeqn(df)
df$parms$b_y <- rep(1,df$tEnd) ## 1 is no ramp (exp(-0.5*B) in recruits; b*lnRy in like))
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_yk",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
"log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh",
"all_srv"))
mappy
paste0(c(as.character(unlist(df$fltnames_surv)),
as.character(unlist(df$fltnames_acomp)[c(2,4,5)])))[-c(1,4)]
names(df$selShape_fish)
names(df$selShape_surv)
names(df$srv_blks)
df$srv_blks
colnames(df$srv_blks)
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_yk",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
"log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh",
# "all_srv"))
colnames(df$srv_blks)[-c(6)] ))
mappy
array(mappy$log_srv_slx_pars, dim = c(df$nfleets_surv+df$nfleets_acomp-4,2,max(df$srv_blks_size),2),
dimnames = dimnames(df$parms$log_srv_slx_pars))
df$parms$log_srv_slx_pars
colnames(df$srv_blks)
array(mappy$log_srv_slx_pars, dim = c(ncol(df$srv_blks),2,max(df$srv_blks_size),2),
dimnames = dimnames(df$parms$log_srv_slx_pars))
# stop("fx not ready to automate fixing survey slx")
srv_slx_map <- array(1:length(df$parms$log_srv_slx_pars),
dim = dim(df$parms$log_srv_slx_pars),
dimnames = dimnames(df$parms$log_srv_slx_pars))
srv_slx_map
fixFlt
fixFlt =
colnames(df$srv_blks)[6]
fixFlt
srv_slx_map[row.names(srv_slx_map) == flt,1:2,,1:2] <- factor(NA) ## fix all designated fleets
for(flt in fixFlt){
srv_slx_map[row.names(srv_slx_map) == flt,1:2,,1:2] <- factor(NA) ## fix all designated fleets
}
srv_slx_map
mappy <-
buildMap(toFix =  c("omega_0ij",
"logh_k",
"logSDR",
# "tildeR_yk",
"b_y",
"epsilon_tau",
"logpi_acomp",
"log_fsh_slx_pars",
"log_srv_slx_pars",
"mort_k"),
fixFlt = c("all_fsh",
# "all_srv"))
colnames(df$srv_blks)[6] ))
array(mappy$log_srv_slx_pars,
dim = c(ncol(df$srv_blks),2,max(df$srv_blks_size),2),
dimnames = dimnames(df$parms$log_srv_slx_pars))
system.time(obj <- MakeADFun(df,
parameters = df$parms,
dll = dllUSE,
# random = "tildeR_y",
map = mappy, ## fix everything for testing eigen fails
checkParameterOrder = TRUE))

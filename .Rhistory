}
}
tmball <- c(data, conf, simFlag = as.numeric(sim.condRE))
if (is.null(tmball$resFlag)) {
tmball$resFlag <- 0
}
nmissing <- sum(is.na(data$logobs))
parameters$missing <- numeric(nmissing)
ran <- c("logN", "logF", "missing")
obj <- MakeADFun(tmball, parameters, random = ran, DLL = "CopyOfstockassessment",
...)
if (rm.unidentified) {
gr <- obj$gr()
safemap <- obj$env$parList(gr)
safemap <- safemap[!names(safemap) %in% ran]
safemap <- lapply(safemap, function(x) factor(ifelse(abs(x) >
1e-15, 1:length(x), NA)))
ddd <- list(...)
if (!is.null(ddd$map)) {
safemap <- c(ddd$map, safemap)
ddd$map <- safemap
ddd$data <- tmball
ddd$parameters <- parameters
ddd$random <- ran
obj <- do.call(MakeADFun, ddd)
}
else {
obj <- MakeADFun(tmball, parameters, random = ran,
map = safemap, DLL = "CopyOfstockassessment", ...)
}
}
lower2 <- rep(-Inf, length(obj$par))
upper2 <- rep(Inf, length(obj$par))
for (nn in names(lower)) lower2[names(obj$par) == nn] = lower[[nn]]
for (nn in names(upper)) upper2[names(obj$par) == nn] = upper[[nn]]
if (!run)
return(list(sdrep = NA, pl = parameters, plsd = NA,
data = data, conf = conf, opt = NA, obj = obj))
opt <- nlminb(obj$par, obj$fn, obj$gr, control = list(trace = 1,
eval.max = 2000, iter.max = 1000, rel.tol = rel.tol),
lower = lower2, upper = upper2)
for (i in seq_len(newtonsteps)) {
g <- as.numeric(obj$gr(opt$par))
h <- optimHess(opt$par, obj$fn, obj$gr)
opt$par <- opt$par - solve(h, g)
opt$objective <- obj$fn(opt$par)
}
rep <- obj$report()
sdrep <- sdreport(obj, opt$par, ignore.parm.uncertainty = ignore.parm.uncertainty)
idx <- c(which(names(sdrep$value) == "lastLogN"), which(names(sdrep$value) ==
"lastLogF"))
sdrep$estY <- sdrep$value[idx]
sdrep$covY <- sdrep$cov[idx, idx]
idx <- c(which(names(sdrep$value) == "beforeLastLogN"),
which(names(sdrep$value) == "beforeLastLogF"))
sdrep$estYm1 <- sdrep$value[idx]
sdrep$covYm1 <- sdrep$cov[idx, idx]
pl <- as.list(sdrep, "Est")
plsd <- as.list(sdrep, "Std")
sdrep$cov <- NULL
ret <- list(sdrep = sdrep, pl = pl, plsd = plsd, data = data,
conf = conf, opt = opt, obj = obj, rep = rep, low = lower,
hig = upper)
# attr(ret, "RemoteSha") <- substr(packageDescription("CopyOfstockassessment")$RemoteSha,
#                                  1, 12)
# attr(ret, "Version") <- packageDescription("CopyOfstockassessment")$Version
class(ret) <- "sam" ## keep this for using stockassessment:: plotting functions
return(ret)
}
# Now we are ready to optimize the model. This function runs the TMB call
fit <- runMod(dat,conf,par) ## currently calling CopyOfstockassessment
stockassessment:::ssbplot(fit) ## this
dat
surveys
sw
str(dat)
?attr
attr(5)
attr(5,2)
attr(5,"length")
attr(5,"type")
attr(c(5,2,43),"type")
attr(dat, "type")
## format data
dat <- makeDat(surveys=surveys,
residual.fleet=cn,
prop.mature=mo,
stock.mean.weight=sw,
catch.mean.weight=cw,
dis.mean.weight=dw,
land.mean.weight=lw,
prop.f=pf,
prop.m=pm,
natural.mortality=nm,
land.frac=lf)
## Load real data and pass to build_dat, build_pars to get in TMB-friendly format
surv <- read.csv("input/cleaned/clean_survey.csv")
surv
# Landings & Discards ----
ccbase <- SS_output("./input/raw/CC_2019_100.00/", forecast = FALSE, covar = FALSE) ## from STAR - possibly not the most updated
require(r4ss)
# Landings & Discards ----
ccbase <- SS_output("./input/raw/CC_2019_100.00/", forecast = FALSE, covar = FALSE) ## from STAR - possibly not the most updated
ccbase$catch %>%
select(Fleet_Name, Yr, Obs, ret_bio)
require(dplyr)
ccbase$catch %>%
select(Fleet_Name, Yr, Obs, ret_bio)
## METHOD 2
# cc_catdis <-
ccbase$catch %>%
select(Fleet_Name, Yr, Obs, ret_bio) %>%
mutate(discard = Obs-ret_bio) %>%
select(Fleet_Name, Yr, Obs) %>%
tidyr::pivot_wider(names_from = Fleet_Name, id_cols = c("Obs"))
## METHOD 2
# cc_catdis <-
ccbase$catch %>%
select(Fleet_Name, Yr, Obs, ret_bio) %>%
mutate(discard = Obs-ret_bio) %>%
select(Fleet_Name, Yr, Obs) %>%
tidyr::pivot_wider(names_from = Fleet_Name, id_cols =Obs)
## METHOD 2
# cc_catdis <-
ccbase$catch %>%
select(Fleet_Name, Yr, Obs, ret_bio) %>%
mutate(discard = Obs-ret_bio) %>%
select(Fleet_Name, Yr, Obs) %>%
tidyr::pivot_wider(names_from = Fleet_Name,  values_from = Obs)
surveys
class(surveys)
dat$sampleTimes
str(dat)
dat$idx1
dat$idxCor
dat$noFleets
dat$fleetTypes
dat$idx1
head(surveys$`HERAS								`)
head(surveys$`IBTS0								`)
View(dat$idx1)
View(dat$idx2)
outer(newfleet, newyear, Vectorize(mmfun, c("f",
"y")), ff = min)
makeDat
?makeDat
dat$maxAgePerFleet
names(attributes(wc))
names(attributes(cw))
names(attributes(cw))[1]
fleet.idx <- 0
type <- NULL
time <- NULL
name <- NULL
corList <- list()
idxCor <- matrix(NA, nrow = length(fleets) + length(surveys) +
1, ncol = nrow(natural.mortality))
prop.mature
mo
residual.fleet=cn
prop.mature=mo
stock.mean.weight=sw
catch.mean.weight=cw
dis.mean.weight=dw
land.mean.weight=lw
prop.f=pf
prop.m=pm
natural.mortality=nm
land.frac=lf
fleet.idx <- 0
type <- NULL
time <- NULL
name <- NULL
corList <- list()
idxCor <- matrix(NA, nrow = length(fleets) + length(surveys) +
1, ncol = nrow(natural.mortality))
idxCor
fleets = NULL
idxCor <- matrix(NA, nrow = length(fleets) + length(surveys) +
1, ncol = nrow(natural.mortality))
idxCor
colnames(idxCor) <- rownames(natural.mortality)
idxCor
dat <- data.frame(year = NA, fleet = NA, age = NA, aux = NA)
weight <- NULL
doone <- function(m) { ## single fleet per input dataset
year <- rownames(m)[row(m)] ## rowNAMES are years
fleet.idx <<- fleet.idx + 1
fleet <- rep(fleet.idx, length(year))
age <- as.integer(colnames(m)[col(m)]) ## assumes columns are age bins
aux <- as.vector(m)
dat <<- rbind(dat, data.frame(year, fleet, age, aux))
if ("weight" %in% names(attributes(m))) {
weight <<- c(weight, as.vector(attr(m, "weight")))
}
else {
if ("cov" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m, "cov"),
diag))
weight <<- c(weight, as.vector(weigthTmp))
}
else {
if ("cov-weight" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m,
"cov-weight"), diag))
weight <<- c(weight, 1/as.vector(weigthTmp))
}
else {
weight <<- c(weight, rep(NA, length(year)))
}
}
}
if ("cov" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov"), cov2cor)
}
if ("cov-weight" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov-weight"),
cov2cor)
}
if ("cor" %in% names(attributes(m))) {
thisCorList <- attr(m, "cor")
whichCorOK <- which(unlist(lapply(thisCorList, function(x) !any(is.na(x)))))
thisCorList <- thisCorList[whichCorOK]
corList <<- c(corList, thisCorList)
nextIdx <- if (all(is.na(idxCor))) {
0
}
else {
max(idxCor, na.rm = TRUE)
}
idxCor[fleet.idx, colnames(idxCor) %in% rownames(m)][whichCorOK] <<- nextIdx:(nextIdx +
length(thisCorList) - 1)
}
}
doone(residual.fleet)
idxCor
m = residual.fleet
year <- rownames(m)[row(m)] ## rowNAMES are years
year
residual.fleet
fleet.idx <<- fleet.idx + 1
fleet.idx
fleet.idx = 1
rep(fleet.idx, length(year))
fleet <- rep(fleet.idx, length(year))
age <- as.integer(colnames(m)[col(m)]) ## assumes columns are age bins
aux <- as.vector(m)
dat <<- rbind(dat, data.frame(year, fleet, age, aux))
dat
names(attributes(m))
"weight" %in% names(attributes(m))
max(idxCor, na.rm = TRUE)
if ("weight" %in% names(attributes(m))) {
weight <<- c(weight, as.vector(attr(m, "weight")))
}
else {
if ("cov" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m, "cov"),
diag))
weight <<- c(weight, as.vector(weigthTmp))
}
else {
if ("cov-weight" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m,
"cov-weight"), diag))
weight <<- c(weight, 1/as.vector(weigthTmp))
}
else {
weight <<- c(weight, rep(NA, length(year)))
}
}
}
if ("weight" %in% names(attributes(m))) {
weight <<- c(weight, as.vector(attr(m, "weight")))
}
else {
if ("cov" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m, "cov"),
diag))
weight <<- c(weight, as.vector(weigthTmp))
}
else {
if ("cov-weight" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m,
"cov-weight"), diag))
weight <<- c(weight, 1/as.vector(weigthTmp))
}
else {
weight <<- c(weight, rep(NA, length(year)))
}
}
}
if ("cov" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov"), cov2cor)
}
if ("cov-weight" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov-weight"),
cov2cor)
}
if ("cor" %in% names(attributes(m))) {
thisCorList <- attr(m, "cor")
whichCorOK <- which(unlist(lapply(thisCorList, function(x) !any(is.na(x)))))
thisCorList <- thisCorList[whichCorOK]
corList <<- c(corList, thisCorList)
nextIdx <- if (all(is.na(idxCor))) {
0
}
else {
max(idxCor, na.rm = TRUE)
}
if ("weight" %in% names(attributes(m))) {
weight <<- c(weight, as.vector(attr(m, "weight")))
}
else {
if ("cov" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m, "cov"),
diag))
weight <<- c(weight, as.vector(weigthTmp))
}
else {
if ("cov-weight" %in% names(attributes(m))) {
weigthTmp = do.call(rbind, lapply(attr(m,
"cov-weight"), diag))
weight <<- c(weight, 1/as.vector(weigthTmp))
}
else {
weight <<- c(weight, rep(NA, length(year)))
}
}
}
if ("cov" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov"), cov2cor)
}
if ("cov-weight" %in% names(attributes(m))) {
attr(m, "cor") <- lapply(attr(m, "cov-weight"),
cov2cor)
}
if ("cor" %in% names(attributes(m))) {
thisCorList <- attr(m, "cor")
whichCorOK <- which(unlist(lapply(thisCorList, function(x) !any(is.na(x)))))
thisCorList <- thisCorList[whichCorOK]
corList <<- c(corList, thisCorList)
nextIdx <- if (all(is.na(idxCor))) {
0
}
else {
max(idxCor, na.rm = TRUE)
}
idxCor[fleet.idx, colnames(idxCor) %in% rownames(m)][whichCorOK] <<- nextIdx:(nextIdx +
length(thisCorList) - 1)
}
}
!is.null(residual.fleet)
doone(residual.fleet)
dat$fleet
str(dat)
doone(surveys)
surveys
is.data.frame(surveys) | is.matrix(surveys)
dummy <- lapply(surveys, doone)
data
unique(dat$fleet)
attr(dat, "name")
rm(dat)
## format data
dat <- makeDat(surveys=surveys,
residual.fleet=cn,
prop.mature=mo,
stock.mean.weight=sw,
catch.mean.weight=cw,
dis.mean.weight=dw,
land.mean.weight=lw,
prop.f=pf,
prop.m=pm,
natural.mortality=nm,
land.frac=lf)
dat$fleetTypes
as.integer(colnames(surveys)
)
min(as.integer(colnames(surveys))) <
(-0.5)
as.integer(colnames(surveys))
colnames(surveys)
surveys
unlist(lapply(surveys, function(x) ifelse(min(as.integer(colnames(x))) <
(-0.5), 3, 2)))
lapply(surveys, function(x) ifelse(min(as.integer(colnames(x)))
)
)
lapply(surveys, function(x) ias.integer(colnames(x))
)
lapply(surveys, function(x) as.integer(colnames(x)))
dat$minAgePerFleet
dat$maxAgePerFleet
dat$idx1
ccdat <- SS_readdat(file = "./input/raw/CC_2019_100.00/data.ss")
ccdat$agecomp$fleet <-   ccdat$fleetnames[ccdat$agecomp$FltSvy ] ## rename fleets
ccdat$lencomp$fleet <-   ccdat$fleetnames[ccdat$lencomp$FltSvy ] ## rename fleets
ccdat$agecomp %>%
mutate(Year = Yr, subarea = NA, stock = NA, mgmt = "CC", type = 'age_comp' ) %>%
select(-Seas, - FltSvy, -Gender, -Part, -Ageerr, -Lbin_lo, -Yr, -Lbin_hi) %>%
select(Year, fleet, type, subarea,stock, mgmt, Nsamp, everything())
unique(ccdat$agecomp$fleet)
## METHOD 2
ccdat$agecomp %>%
mutate(Year = Yr, subarea = NA, stock = NA, mgmt = "CC", type = 'age_comp' ) %>%
select(-Seas, - FltSvy, -Gender, -Part, -Ageerr, -Lbin_lo, -Yr, -Lbin_hi) %>%
select(Year, fleet, type, subarea,stock, mgmt, Nsamp, everything()) %>%
split( . , f = fleet )
## METHOD 2
ccdat$agecomp %>%
mutate(Year = Yr, subarea = NA, stock = NA, mgmt = "CC", type = 'age_comp' ) %>%
select(-Seas, - FltSvy, -Gender, -Part, -Ageerr, -Lbin_lo, -Yr, -Lbin_hi) %>%
select(Year, fleet, type, subarea,stock, mgmt, Nsamp, everything()) %>%
group_split(fleet)
attr(dat, "idx1")
surveys
dat$nobs
dat$logobs
head(dat$idx1)
## format data
dat2 <- makeDat(surveys=surveys,
residual.fleet=cn,
prop.mature=mo,
stock.mean.weight=sw,
catch.mean.weight=cw,
dis.mean.weight=dw,
land.mean.weight=lw,
prop.f=pf,
prop.m=pm,
natural.mortality=nm,
land.frac=lf)
definit
data3 <- cleanCatch(dat2, conf)
data3
str(data3)
obj
obj <- MakeADFun(tmball, parameters, random = ran, DLL = "CopyOfstockassessment"
)
tmball <- c(data, conf, simFlag = as.numeric(sim.condRE))
tmball <- c(data, conf, simFlag = as.numeric(FALSE))
obj <- MakeADFun(tmball, parameters, random = ran, DLL = "CopyOfstockassessment"
)
rm.unidentified
if (length(conf$maxAgePlusGroup) == 1) {
tmp <- conf$maxAgePlusGroup
conf$maxAgePlusGroup <- modConfig(data)$maxAgePlusGroup
conf$maxAgePlusGroup[1] <- tmp
}
definit <- makePar(data, conf)
data = data2
data = data2
data = dat2
if (length(conf$maxAgePlusGroup) == 1) {
tmp <- conf$maxAgePlusGroup
conf$maxAgePlusGroup <- modConfig(data)$maxAgePlusGroup
conf$maxAgePlusGroup[1] <- tmp
}
definit <- makePar(data, conf)
if (!identical(parameters, relist(unlist(parameters), skeleton = definit))) {
warning("Initial values are not consistent, so running with default init values from makePars()")
parameters <- definit
}
data <- cleanCatch(data, conf)
parameters = pars
parameters = par
for (i in 1:length(confTmp)) {
if (!names(confTmp)[i] %in% names(conf)) {
conf[[length(conf) + 1]] = confTmp[[i]]
names(conf)[length(conf)] = names(confTmp)[i]
}
}
definit <- makePar(data, conf)
if (!identical(parameters, relist(unlist(parameters), skeleton = definit))) {
warning("Initial values are not consistent, so running with default init values from makePars()")
parameters <- definit
}
data <- cleanCatch(data, conf)
confTmp = modConfig(data) ## reconfig based on cleaned dat
for (i in 1:length(confTmp)) {
if (!names(confTmp)[i] %in% names(conf)) {
conf[[length(conf) + 1]] = confTmp[[i]]
names(conf)[length(conf)] = names(confTmp)[i]
}
}
tmball <- c(data, conf, simFlag = as.numeric(sim.condRE))
if (is.null(tmball$resFlag)) {
tmball$resFlag <- 0
}
nmissing <- sum(is.na(data$logobs))
parameters$missing <- numeric(nmissing)
ran <- c("logN", "logF", "missing")
obj <- MakeADFun(tmball, parameters, random = ran, DLL = "CopyOfstockassessment",
...)
obj <- MakeADFun(tmball, parameters, random = ran, DLL = "CopyOfstockassessment"
)
# Now we are ready to optimize the model. This function runs the TMB call
fit <- runMod(dat2,conf,par) ## currently calling CopyOfstockassessment
?predNFun
conf$stockRecruitmentModelCode
conf$keyLogFsta
conf$keyBiomassTreat
-1-1
dat$fleetTypes
conf$minAge
dat$aux[1,2]
dat$aux
dat$aux[1,]
dat$maxAgePerFleet
conf$maxAgePlusGroup
conf$keyQpow
conf$keyBiomassTreat
